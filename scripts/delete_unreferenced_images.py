#!/usr/bin/env python3
"""
Script to delete unreferenced images based on the output from find_unreferenced_images.py

This script:
1. Reads the list of unreferenced images from 'unreferenced_images.txt'
2. Optionally displays a preview of what will be deleted
3. Asks for confirmation before deletion
4. Deletes the files and removes empty directories

SAFETY FEATURES:
- Requires explicit confirmation before deletion
- Shows preview of files to be deleted
- Creates a backup list of deleted files
- Only deletes files that actually exist
- Removes empty directories after deletion

Usage:
    python delete_unreferenced_images.py [--dry-run] [--force]
    
Options:
    --dry-run    Show what would be deleted without actually deleting
    --force      Delete without asking for confirmation (use with caution!)
"""

import os
import sys
import argparse
from pathlib import Path

def read_unreferenced_images(filename='unreferenced_images.txt'):
    """Read the list of unreferenced images from file."""
    if not os.path.exists(filename):
        print(f"Error: File '{filename}' not found!")
        print("Please run 'find_unreferenced_images.py' first to generate the list.")
        return []
    
    with open(filename, 'r', encoding='utf-8') as f:
        images = [line.strip() for line in f if line.strip()]
    
    return images

def get_file_size(file_path):
    """Get human-readable file size."""
    try:
        size = os.path.getsize(file_path)
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} TB"
    except OSError:
        return "Unknown"

def preview_deletion(images):
    """Show a preview of what will be deleted."""
    existing_images = [img for img in images if os.path.exists(img)]
    missing_images = [img for img in images if not os.path.exists(img)]
    
    print(f"\n=== DELETION PREVIEW ===")
    print(f"Files to be deleted: {len(existing_images)}")
    print(f"Files already missing: {len(missing_images)}")
    
    if missing_images:
        print(f"\nFiles that no longer exist (will be skipped):")
        for img in missing_images[:5]:  # Show first 5
            print(f"  - {img}")
        if len(missing_images) > 5:
            print(f"  ... and {len(missing_images) - 5} more")
    
    if existing_images:
        total_size = sum(os.path.getsize(img) for img in existing_images if os.path.exists(img))
        print(f"\nFiles to be deleted (Total size: {get_file_size_from_bytes(total_size)}):")
        
        # Group by directory for better overview
        by_dir = {}
        for img in existing_images:
            dir_name = os.path.dirname(img)
            if dir_name not in by_dir:
                by_dir[dir_name] = []
            by_dir[dir_name].append(os.path.basename(img))
        
        for dir_name in sorted(by_dir.keys()):
            files = by_dir[dir_name]
            print(f"\n  {dir_name}/ ({len(files)} files):")
            for file in sorted(files)[:3]:  # Show first 3 files
                full_path = os.path.join(dir_name, file)
                size = get_file_size(full_path)
                print(f"    - {file} ({size})")
            if len(files) > 3:
                print(f"    ... and {len(files) - 3} more files")
    
    return existing_images

def get_file_size_from_bytes(size_bytes):
    """Convert bytes to human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f} TB"

def delete_files(images, dry_run=False):
    """Delete the files and create a log of deleted files."""
    if not images:
        print("No files to delete.")
        return []
    
    deleted_files = []
    deleted_log_file = 'deleted_images_log.txt'
    
    print(f"\n{'DRY RUN: ' if dry_run else ''}Deleting files...")
    
    # Create log file
    if not dry_run:
        with open(deleted_log_file, 'w', encoding='utf-8') as log:
            log.write("# Deleted unreferenced images log\n")
            log.write(f"# Generated by delete_unreferenced_images.py\n\n")
    
    for i, image_path in enumerate(images, 1):
        if not os.path.exists(image_path):
            print(f"  [{i:3d}/{len(images)}] SKIP (missing): {image_path}")
            continue
        
        try:
            file_size = get_file_size(image_path)
            if dry_run:
                print(f"  [{i:3d}/{len(images)}] WOULD DELETE: {image_path} ({file_size})")
            else:
                os.remove(image_path)
                deleted_files.append(image_path)
                print(f"  [{i:3d}/{len(images)}] DELETED: {image_path} ({file_size})")
                
                # Log the deletion
                with open(deleted_log_file, 'a', encoding='utf-8') as log:
                    log.write(f"{image_path}\n")
        
        except Exception as e:
            print(f"  [{i:3d}/{len(images)}] ERROR deleting {image_path}: {e}")
    
    return deleted_files

def remove_empty_directories(base_dir='content', dry_run=False):
    """Remove empty directories after file deletion."""
    removed_dirs = []
    
    for root, dirs, files in os.walk(base_dir, topdown=False):
        # Skip the base directory itself
        if root == base_dir:
            continue
        
        # Check if directory is empty
        if not dirs and not files:
            try:
                if dry_run:
                    print(f"  WOULD REMOVE empty directory: {root}")
                else:
                    os.rmdir(root)
                    removed_dirs.append(root)
                    print(f"  REMOVED empty directory: {root}")
            except Exception as e:
                print(f"  ERROR removing directory {root}: {e}")
    
    return removed_dirs

def main():
    parser = argparse.ArgumentParser(description='Delete unreferenced images from the optics textbook')
    parser.add_argument('--dry-run', action='store_true', 
                       help='Show what would be deleted without actually deleting')
    parser.add_argument('--force', action='store_true', 
                       help='Delete without asking for confirmation')
    parser.add_argument('--input-file', default='unreferenced_images.txt',
                       help='Input file with list of unreferenced images (default: unreferenced_images.txt)')
    
    args = parser.parse_args()
    
    print("=== Unreferenced Images Deletion Tool ===\n")
    
    # Read the list of unreferenced images
    unreferenced_images = read_unreferenced_images(args.input_file)
    
    if not unreferenced_images:
        print("No unreferenced images found to delete.")
        return
    
    # Show preview
    existing_images = preview_deletion(unreferenced_images)
    
    if not existing_images:
        print("\nNo files exist to delete.")
        return
    
    # Ask for confirmation unless --force or --dry-run
    if not args.force and not args.dry_run:
        print(f"\nThis will PERMANENTLY DELETE {len(existing_images)} image files.")
        print("A log of deleted files will be saved to 'deleted_images_log.txt'")
        
        while True:
            response = input("\nProceed with deletion? (yes/no): ").lower().strip()
            if response in ['yes', 'y']:
                break
            elif response in ['no', 'n']:
                print("Deletion cancelled.")
                return
            else:
                print("Please answer 'yes' or 'no'")
    
    # Delete the files
    deleted_files = delete_files(existing_images, dry_run=args.dry_run)
    
    # Remove empty directories
    if not args.dry_run and deleted_files:
        print(f"\nRemoving empty directories...")
        removed_dirs = remove_empty_directories(dry_run=args.dry_run)
    
    # Summary
    print(f"\n=== SUMMARY ===")
    if args.dry_run:
        print(f"DRY RUN completed.")
        print(f"Would delete: {len(existing_images)} files")
    else:
        print(f"Deletion completed.")
        print(f"Files deleted: {len(deleted_files)}")
        if deleted_files:
            print(f"Deletion log saved to: deleted_images_log.txt")
        if 'removed_dirs' in locals():
            print(f"Empty directories removed: {len(removed_dirs)}")

if __name__ == "__main__":
    main()